module z1top # (
  // We are using a 125 MHz input clock for our design.
  // It is declared as a parameter so the testbench can override it if desired
  // This clock isn't used directly
  parameter SYSTEM_CLOCK_FREQ = 125_000_000,

  // CPU clock frequency in Hz.
  // This is generated by one of the Zynq's PLLs. The PLL must be configured
  // to generate this value.
  parameter CPU_CLOCK_FREQ =72_500_000,

  // These are used for the button debouncer.
  // They are overridden in the testbench for faster runtime.
  parameter integer B_SAMPLE_COUNT_MAX = 0.0002 * SYSTEM_CLOCK_FREQ,
  parameter integer B_PULSE_COUNT_MAX = 0.03/0.0002
) (
  input USER_CLK,             // 125 MHz clock.

  input RESET,
  input [2:0] BUTTONS,        // Momentary push-buttons.
  input [1:0] SWITCHES,       // Slide switches
  output [5:0] LEDS,          // Board LEDs.

  // UART connections
  input FPGA_SERIAL_RX,
  output FPGA_SERIAL_TX
);

  // -------------------------------------------------------------------------
  // Clocking
  // -------------------------------------------------------------------------

  wire user_clk_g;

  IBUFG user_clk_buf  (.I(USER_CLK),           .O(user_clk_g));

  wire cpu_clk, cpu_clk_g, cpu_clk_pll_lock;
  wire cpu_clk_pll_fb_out, cpu_clk_pll_fb_in;

  BUFG  cpu_clk_buf     (.I(cpu_clk),               .O(cpu_clk_g));
  BUFG  cpu_clk_f_buf   (.I(cpu_clk_pll_fb_out),    .O (cpu_clk_pll_fb_in));
 
  // Magical instantiation of a PLL on the Zynq chip. (If you're curious,
  // you can create one yourself with the Clocking Wizard IP.) The first PLL
  // is for your RISC-V CPU clock.
  PLLE2_ADV
  #(
    .BANDWIDTH            ("OPTIMIZED"),
    .COMPENSATION         ("BUF_IN"),  // Not "ZHOLD"
    .STARTUP_WAIT         ("FALSE"),
    .DIVCLK_DIVIDE        (5),
    .CLKFBOUT_MULT        (58),
    .CLKFBOUT_PHASE       (0.000),
    .CLKOUT0_DIVIDE       (20),
    .CLKOUT0_PHASE        (0.000),
    .CLKOUT0_DUTY_CYCLE   (0.500),
    .CLKIN1_PERIOD        (8.000))
  plle2_cpu_inst
  // Output clocks
  (
    .CLKFBOUT            (cpu_clk_pll_fb_out),
    .CLKOUT0             (cpu_clk),
     // Input clock control
    .CLKFBIN             (cpu_clk_pll_fb_in),
    .CLKIN1              (user_clk_g),
    .CLKIN2              (1'b0),
     // Tied to always select the primary input clock
    .CLKINSEL            (1'b1),
    // Other control and status signals
    .LOCKED              (cpu_clk_pll_lock),
    .PWRDWN              (1'b0),
    .RST                 (1'b0));

  // -------------------------------------------------------------------------
  // User I/O, including resets
  // -------------------------------------------------------------------------

  // The global system reset is asserted when the RESET button is
  // pressed by the user or when the PLL isn't locked
  wire [2:0] clean_buttons;
  wire reset_button, reset;
  assign reset = reset_button || ~cpu_clk_pll_lock;

  button_parser #(
    .width(4),
    .sample_count_max(B_SAMPLE_COUNT_MAX),
    .pulse_count_max(B_PULSE_COUNT_MAX)
  ) b_parser (
    .clk(cpu_clk_g),
    .in({RESET, BUTTONS}),
    .out({reset_button, clean_buttons})
  );
  // Insert the rest of your code here: I/O, audio, CPU...

  Riscv151 #(
    .SYSTEM_CLOCK_FREQ(SYSTEM_CLOCK_FREQ),
    .CPU_CLOCK_FREQ(CPU_CLOCK_FREQ)
  ) CPU (
    .clk(cpu_clk_g),
    .rst(reset),
    .FPGA_SERIAL_RX(FPGA_SERIAL_RX),
    .FPGA_SERIAL_TX(FPGA_SERIAL_TX),
    .buttons_raw(clean_buttons),
    .switches(SWITCHES),
    .leds(LEDS)
  );

endmodule
